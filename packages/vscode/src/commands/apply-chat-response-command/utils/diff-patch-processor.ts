// Custom diff patch processor for applying unified diff patches to files
//
// This custom processor is more reliable than using 'git apply' or 'wiggle' for appling
// diff patches generated by an AI model. As long as the AI model can add the approperate
// + and - lines and get the code correct the patch should be applied correctly.
//
// Takes a unified diff patch and treats it as a search and replace operation
// ignoreing diff headers and line counts.
//
// Copies of the original code and patch are both normilized to remove line endings, white space and
// case differences with special treatment for unmodified context code and new lines. Then the patch 
// is split into search and replace blocks. The normilized code is then iterated over for the search 
// blocks storing the index of the first line of the block if found. The search blocks are then applied 
// to the original code at the found index replacing the search block with the replace block.
//
// Possible future improvements:
// - If a search block is not found create a rejected patch file for that block and apply
//   any blocks found.
// - Add support for finding partial blocks. Not as accurate and higher risk of false positives.

import * as vscode from 'vscode'
import * as path from 'path'
import * as fs from 'fs'

class SearchBlock
{
    public searchLines: string[];
    public replaceLines: string[];
    public searchBlockStartIndex: number;

    public constructor(searchLines: string[], replaceLines: string[], searchBlockStartIndex: number) 
    {
        this.searchLines = searchLines;
        this.replaceLines = replaceLines;
        this.searchBlockStartIndex = searchBlockStartIndex;
    }

    get_start_index() { return this.searchBlockStartIndex; }
    get_search_count() { return this.searchLines.length; }
}

export async function process_diff_patch(file_path: string, diff_path_patch: string) : Promise<boolean>
{
    if (!fs.existsSync(file_path)) // Check if file exists, if not then create it and any directories
    {
        try 
        {
            // Ensure the directory exists
            const dirPath = path.dirname(file_path);
            await fs.promises.mkdir(dirPath, { recursive: true });

            // Write the new file
            await fs.promises.writeFile(file_path, "", { flag: 'w' });

            // Delay to prevent file system issues when creating a lot of files quickly
            await new Promise(f => setTimeout(f, 500));

            console.log(`File created successfully at: ${file_path}`);
        } 
        catch (error: any) 
        {
            console.error(`Error creating file: ${error.message}`);

            return false;
        }
    }

    const file_content = fs.readFileSync(file_path, 'utf8');
    const diff_patch_content = fs.readFileSync(diff_path_patch, 'utf8');

    let result = "";

    // New file or apply diff
    if (diff_patch_content.includes('--- /dev/null'))
    {
        // New file
        result = create_new_file_from_patch(diff_patch_content);
    }
    else
    {
        // Apply diff
        result = apply_diff_patch(file_content, diff_patch_content);
    }

    if (result === "error")
    {
        return false;
    }

    // Save result to file
    vscode.workspace.fs.writeFile(vscode.Uri.file(file_path), Buffer.from(result, 'utf8'))
        .then(() => {
            console.log('File saved successfully');
        }, (error) => {
            console.error('Error saving file:', error);

            return false;
        });

    return true;
}

function create_new_file_from_patch(diffPatch: string) : string
{
    let newFileContent = "";

    const patchNormilized = diffPatch.replace(/\r\n/g, '\n');
    const patchLines = patchNormilized.split('\n');

    for (let i = 0; i < patchLines.length; i++) 
    {
        const line = patchLines[i];

        // Skip patch header and chunk identifier lines
        if (line.startsWith('diff --git') || line.startsWith('index') || line.startsWith('new file mode') ||
            line.startsWith('---') || line.startsWith('+++') || line.startsWith('@@'))
        {
            continue;
        }

        newFileContent += line.replace(/^\+/, '') + '\n';
    }

    return newFileContent;
}

function apply_diff_patch(originalCode: string, diffPatch: string) : string
{
    try 
    {
        const originalCodeNormilized = originalCode.replace(/\r\n/g, '\n'); // Remove windows line endings
        const originalCodeLines = originalCodeNormilized.split(/^/m); // Split by new line
        const originalCodeLinesNormalized = [];
      
        const patchNormilized = diffPatch.replace(/\r\n/g, '\n'); // Remove windows line endings
        const patchLines = patchNormilized.split('\n'); // Split by new line
        const patchLinesOriginal = [];
        const patchLinesNormalized = [];

        // === Count new lines at the end of the original text ===
        const trailingNewLines = count_trailing_new_lines(originalCode);

        // .split will miss the last new line so we must add it manually if any exist
        if (trailingNewLines > 0)
        {
            originalCodeLines.push('\n');
        }
        
        // === Normalize the code lines ===
        let lineCount = 0;
        for (let i = 0; i < originalCodeLines.length; i++) 
        {
            let line = originalCodeLines[i];

            // Treat empty new lines as ~nnn
            if (line.trim() === '') 
            {
                line = '~nnn';
            }

            // Remove all line endings
            const lineNormalized = line.replace(/\r\n/g, '').replace(/\r/g, '').replace(/\n/g, '');

            // Remove all white spaces
            const lineNormalized2 = lineNormalized.replace(/\s+/g, '');

            // Change to lower case
            const lineNormalized3 = lineNormalized2.toLowerCase();

            // Store the normilized code line
            originalCodeLinesNormalized.push({
                key: lineCount,
                value: lineNormalized3
            });

            lineCount++;
        }

        // === Normalize the patch lines ===
        for (let i = 0; i < patchLines.length; i++) 
        {
            let line = patchLines[i];

            // If line is part of git patch header, skip it
            if (line.startsWith('diff --git') || line.startsWith('index') || 
                line.startsWith('---') || line.startsWith('+++')) 
            {
                continue;
            }

            // Treat empty new lines as ~nnn
            if (line.trim() === '') // Orignal empty line
            {
                line = '~nnn';
            }
            else if (line.trim() === '+') // Add empty line
            {
                line = '+~nnn';
            }
            else if (line.trim() === '-') // Remove empty line
            {
                line = '-~nnn';
            }

            // Save original patch line for applying later. Remove leading space.
            patchLinesOriginal.push(line.startsWith(' ') ? line.substring(1, line.length) : line);

            // Remove all line endings
            let lineNormalized = line.replace(/\r\n/g, '').replace(/\r/g, '').replace(/\n/g, '');

            // If white space at start convert to ~
            if (lineNormalized.startsWith(' ')) 
            {
                lineNormalized = lineNormalized.replace(/^\s+/, '~');
            }

            // Remove all white spaces
            const lineNormalized2 = lineNormalized.replace(/\s+/g, '');

            // Change to lower case
            const lineNormalized3 = lineNormalized2.toLowerCase();

            // Store the normilized patch line
            patchLinesNormalized.push(lineNormalized3);
        }

        // if line does not start with + or - then is unmodified code add to search and replace
        // if line starts with - then add to search
        // if line starts with ~ then add to search and replace
        // if line starts with + then add to replace

        // Contains the search and replace chunks
        const searchReplaceBlocks = [];

        // Contains the search and replace lines for each chunk
        let searchChunks = [];
        let replaceChunks = [];

        // === Process the patch lines ===
        let insideReplaceBlock = false;
        for (let i = 0; i < patchLinesNormalized.length; i++)
        {
            const line = patchLinesNormalized[i];
            const lineOriginal = patchLinesOriginal[i]

            if (line.startsWith('@@')) // Start of new hunk
            {
                // Reset for new hunk
                searchChunks = [];
                replaceChunks = [];
                insideReplaceBlock = false;
            }

            if (line.startsWith('-') || line.startsWith('~'))
            {
                if (insideReplaceBlock) // We hit a new search block, store the previous one
                {
                    insideReplaceBlock = false;

                    // Don't add the block if there is no matching search or replace
                    if (searchChunks.length > 0 || replaceChunks.length > 0)
                    {
                        // Add the previous search block to the searchReplaceBlocks
                        searchReplaceBlocks.push(new SearchBlock(searchChunks, replaceChunks, -1));
                    }
 
                    // Clear the search and replace chunks
                    searchChunks = [];
                    replaceChunks = [];
                }

                if (line.startsWith('--')) 
                {
                    // Remove the leading '-' from the search line only if there are two -
                    // Fix for files with lines that start with - eg. markdown
                    searchChunks.push(line.substring(1, line.length));
                }
                else if (line.startsWith('~nnn') || line.startsWith('-~nnn'))
                {
                    searchChunks.push('~nnn');
                }
                else
                {
                    searchChunks.push(line.replace(/^\-/, '').replace(/^\~/, ''));
                }

                // Also replace unchanged lines
                if (line.startsWith('~nnn'))
                {
                    replaceChunks.push(lineOriginal.replace(/^\~nnn/, '') + '\n');
                }
                else if (line.startsWith('~'))
                {
                    replaceChunks.push(lineOriginal.replace(/^\~/, '') + '\n');
                }

                continue;
            }

            if (line.startsWith('+')) 
            {
                insideReplaceBlock = true;

                if (line.startsWith('++')) 
                {
                    // Remove the leading '+' from the search line only if there are two +
                    replaceChunks.push(lineOriginal.substring(1, line.length) + '\n');
                }
                else if (line.startsWith('+~nnn'))
                {
                    // Remove new line tag from start of line
                    replaceChunks.push(lineOriginal.replace(/^\+~nnn/, '') + '\n');
                }
                else
                {
                    // Remove + from start of line
                    replaceChunks.push(lineOriginal.replace(/^\+/, '') + '\n');
                }
            }
        }

        // Reached end of patch. Add the final search block to the searchReplaceBlocks
        if (insideReplaceBlock)
        {
            // Add the previous search block to the searchReplaceBlocks
            searchReplaceBlocks.push(new SearchBlock(searchChunks, replaceChunks, -1));
        }

        // === Work through search and replace blocks finding start of search block ===
        let previousFoundIndex = 0;
        for (let i = 0; i < searchReplaceBlocks.length; i++) 
        {
            const searchReplaceBlock = searchReplaceBlocks[i];

            // Create search string chunk from searchReplaceBlock
            const searchString = searchReplaceBlock.searchLines.join('');

            //console.log('Search string: ' + searchString);

            // Iterate over the originalCodeLinesNormalized to find the search string
            // We start search from the previous found index to ensure duplicate code is not found at wrong index
            let found = false;
            for (let j = previousFoundIndex; j < originalCodeLinesNormalized.length; j++) 
            {
                // Create a chunk of lines from originalCodeLinesNormalized
                const chunk = originalCodeLinesNormalized.slice(j, j + searchReplaceBlock.searchLines.length);
                const chunkString = chunk.map(line => line.value).join('');

                //console.log('Chunk string: ' + chunkString);

                // Check if the chunk matches the search string
                if (chunkString == searchString) 
                {
                    // Check if found index is greater than the previous found index
                    if (previousFoundIndex >= chunk[0].key) 
                    {
                        // This should never happen
                        throw new Error('Found index is less than previous found index');
                    }
                    
                    // Store the index of the first line of the search block
                    searchReplaceBlock.searchBlockStartIndex = chunk[0].key;
                    found = true;

                    previousFoundIndex = chunk[0].key; // Update the previous index

                    //console.log('Found search block at line ' + chunk[0].key);
                    break;
                }
            }

            // If not found, set the searchBlockStartIndex to -1
            if (!found) 
            {
                console.log('Search block not found: ' + searchString);
                searchReplaceBlock.searchBlockStartIndex = -1; // Not found

                return "error";
                //throw new Error('Search block not found: ' + searchString);
            }
        }

        // === Apply the search and replace blocks ===
        // Get all blocks with a valid start index
        const validBlocks = searchReplaceBlocks.filter(block => block.get_start_index() !== -1);

        // Sort blocks by descending index
        validBlocks.sort((a, b) => b.get_start_index() - a.get_start_index());

        let resultLines = [...originalCodeLines]; // Operate on a copy

        // Iterrate over the valid blocks and apply them
        for (const block of validBlocks) 
        {
            const startIndex = block.get_start_index();
            const searchCount = block.get_search_count();
            const replacementContent = block.replaceLines; // These are original lines

            if (startIndex < 0 || startIndex > resultLines.length)  // startIndex can be == resultLines.length for appending
            {
                console.error(`Invalid start index ${startIndex} for block application. Max index: ${resultLines.length - 1}`);
                continue;
            }

            // Ensure searchCount does not exceed available lines from startIndex
            const actualSearchCount = Math.min(searchCount, resultLines.length - startIndex);

            //console.log(`Applying block at index ${startIndex}: removing ${actualSearchCount} lines, inserting ${replacementContent.length} lines.`);
            // Apply the replacement
            resultLines.splice(startIndex, actualSearchCount, ...replacementContent);
        }

        return resultLines.join('');   
    } 
    catch (error) 
    {
        console.error('Error during diff processing:', error);

        return "error";
        //throw new Error('Error during diff processing: ' + error);
    }
}

function count_trailing_new_lines(text: string) : number
{
    let count = 0;
    for (let i = text.length - 1; i >= 0; i--) {
        if (text[i] === '\n') { count++; } else { break; }
    }
  
    return count;
}